# 设计模式
<!--2018-4-27-->
## 为什么要有设计模式：

> 词汇与通用语言的重要性
> 
> 关于设计模式的书籍刚出现的时候，我最初的印象是“夸夸其谈，其实都是些理所当然的内容”。《设计模式》一书所列举的23种模式，很多都是经常使用，并不怎么罕见的模式。而且，还含有很多在C++及Java那样的静态语言中虽然有效，但在Smalltalk及Ruby中却没有多大意义的模式。
> 
> 但过了一阵子我有了深刻的认识。设计模式的本质，并不是介绍至今没有用过的新模式，而是通过给屡屡使用过的模式起一个合适的名字，从而提供了设计时的词汇。
> 
> 人使用语言进行思考。没有语言的系统也就无法思考，不使用语言，也不能与其他人进行交流。人类的生存与人际关系都是跟语言密切相关的。
> 
> 旧约全书记载了巴比伦塔的故事，描写了人与人之间因为语言互不相通，而中止了塔的建设，人们都纷纷散去的场面。语言的重要性可见一斑。
> 
> 据说住在阿拉斯加与加拿大的因纽特人的语言中，表现雪与冰的词汇有80种。居然还需要把这么微妙的差异加以区别。我们也有很多变现雨的词汇，如毛毛雨、初夏雨、秋雨、阵雨等。
> 
> 设计模式也一样。软件开发中，虽然也存在能用于各种局面的类或专业用语，但如果不给它们起一个合适的名字，很多开发人员都不可能意识到它们的存在。设计模式就是将这样的词汇集中起来，并进行分类的一种尝试。所以，书上介绍的23种模式，不过是一个开始。最终还应有一个能收录更多模式的“设计模式目录”。
> 
> 很遗憾，这种目录还没出现。也许人们连现有的23种模式都没能够灵活运用，还没进化到需要追求更多模式的阶段。
> 

## 都有哪些设计模型？

> 模式名|内容
> ---|---
 Abstract Factory（抽象工厂）|用可配置的方法生成有关的对象群
Adapter（适配器）|变换对象的接口
Bridge（桥接）|分离类之间的实现
Builder（生成器）|分离复杂对象的生成过程
Chain of Responsibility（职责链）|用多个对象来处理请求
Command（命令）|把请求封装成对象
Composite（组合）|用树结构来构成对象
Decorator（装饰）|给对象动态增加新的功能
Facade（外观）|隐藏子系统的详细内容，提供统一的接口
Factory Method（工厂方法）|在父类只定义生成对象的接口，具体的生成过程由派生类来实现
Flyweight（享元）|以共享的方式提高大量小对象的实现效率
Interpreter（解释器）|语言解释器
Iterator（迭代器）|提供按顺序访问一组对象的方法
Mediator（中介者）|封装对象之间的相互作用
Memento（备忘录）|记录对象的内部状态
Observer（观察者）|把对象的状态变更通知给其他对象
Prototype（原型）|提供生成对象的原型
Proxy（代理）|提供控制对象访问的代理（容器）
Singleton（单件）|用来保证某个类的实例只有一个
State（状态）|把对象的内部状态独立出来，封装状态变化
Strategy（策略）|封装算法，使之具有可变换性
Template Method（模板方法）|父类定义框架，派生类具体实现其中一部分
Visitor（访问者）|对集合的元素进行操作

## 如何使用设计模型？

我个人觉得在做一个项目前，现将其抽象成一个模型，然后去思考什么解决方案最好，有没有一个很好的设计模式可以解决这些问题。
当然所有使用的前提都应该是你知道有这么一个模型。
过程中如果想办法避免代码重复，那么就先想到模型。当然我也刚开始学习学习设计模型，所以还有很多东西要学习。

<!--2018-4-27-->


